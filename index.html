<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TV Snake Game (16:9)</title>
    
    <style>
        /* --- GLOBAL BOX SIZING --- */
        * {
            box-sizing: border-box;
        }

        /* --- OFFLINE FONT INCLUSION --- */
        @font-face {
            font-family: 'Press Start 2P';
            src: url('PressStart2P.ttf') format('truetype'); 
            font-weight: normal;
            font-style: normal;
        }

        /* Apply font, ensure no scrolling, and hide mouse pointer */
        body {
            font-family: 'Press Start 2P', monospace; 
            background-color: #1f2937;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Fixed height to match viewport */
            margin: 0;
            padding: 10px; /* Minimal padding */
            overflow: hidden; 
            cursor: none !important; /* Hides cursor for Silk/TV browser */
        }

        /* Game container styling - adjusted to fit 720p exactly */
        .game-container {
            background-color: #111827;
            box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.6);
            border-radius: 1rem;
            padding: 1rem;
            max-width: 1320px; 
            width: 100%;
            height: 100%; /* Fill the 100vh body */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center contents vertically */
        }
        
        /* Compact title */
        .title-text {
            font-size: 1.75rem; /* Slightly smaller for vertical space */
            color: #fcd34d;
            margin-top: 0;
            margin-bottom: 0.75rem; 
            text-align: center;
        }
        
        /* Wrapper for the canvas and the overlay */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 1280px; 
            aspect-ratio: 16 / 9; /* Modern way to handle aspect ratio */
            overflow: hidden;
            border-radius: 0.75rem;
            flex-shrink: 1; /* Allow it to shrink if needed to fit screen */
        }

        /* Canvas styling */
        #gameCanvas {
            width: 100%;
            height: 100%;
            border: 6px solid #f97316;
            background-color: #000;
            box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.1);
        }

        /* Score and Control panel - Compact for TV */
        .status-panel {
            color: #fff;
            margin-top: 0.75rem;
            width: 100%;
            max-width: 1280px; 
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .score-display, .info-display {
            padding: 0.5rem 1rem;
            background-color: #374151;
            border-radius: 0.5rem;
            font-size: 0.85rem; /* Slightly smaller font for layout safety */
        }

        .info-display {
            flex-grow: 1; 
            text-align: center;
        }
        
        .info-display:after {
            content: " | P / Enter to Pause | ESC to Exit";
            color: #a7f3d0;
        }

        .hidden {
            display: none !important;
        }

        /* --- Overlay Styles --- */
        #gameOverOverlay, #exitConfirmationModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }

        .exit-modal-box {
            background-color: #1f2937;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 4px solid #f97316;
            text-align: center;
            max-width: 80%;
        }

        .modal-text {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
        }

        .modal-button-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .modal-button {
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            cursor: pointer;
            border: none;
            font-size: 1rem;
            text-transform: uppercase;
            outline: none; 
        }

        .modal-button.focused, .modal-button:focus {
            outline: 4px solid #fcd34d;
            transform: scale(1.05);
        }

        #cancelExitButton { background-color: #34d399; color: #111827; }
        #yesExitButton { background-color: #ef4444; color: #fff; }

        .game-over-text {
            color: #ef4444;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px #f87171;
        }

        .final-score {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        .restart-button {
            padding: 0.8rem 1.6rem;
            background-color: #f97316;
            color: #111827;
            border-radius: 0.5rem;
            cursor: pointer;
            border: none;
            font-size: 1.1rem;
            text-transform: uppercase;
            outline: none; 
        }
        
        .restart-button:focus {
            outline: 6px solid #fcd34d;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="title-text">TV Snake</h1>
        
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="1280" height="720"></canvas>
            
            <div id="gameOverOverlay" class="hidden">
                <p id="gameOverTitle" class="game-over-text">GAME OVER</p>
                <p id="finalScore" class="final-score"></p>
                <button id="restartButton" class="restart-button">▶️ START / RESTART (ENTER)</button>
            </div>
            
            <div id="exitConfirmationModal" class="hidden">
                <div class="exit-modal-box">
                    <p class="modal-text">End current game?</p>
                    <div class="modal-button-group">
                        <button id="cancelExitButton" class="modal-button">Cancel</button>
                        <button id="yesExitButton" class="modal-button">Yes, Exit</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="status-panel">
            <div class="score-display">LVL: <span id="level">1</span> | SCORE: <span id="score">0</span></div>
            <div class="info-display">Use Arrow Keys to Move</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level'); 
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const exitConfirmationModal = document.getElementById('exitConfirmationModal');
        const cancelExitButton = document.getElementById('cancelExitButton');
        const yesExitButton = document.getElementById('yesExitButton');

        const CANVAS_WIDTH = 1280;
        const CANVAS_HEIGHT = 720;
        const TILE_SIZE = 40;
        const MINI_TILE_SIZE = 20; 
        const GRID_WIDTH = CANVAS_WIDTH / TILE_SIZE;
        const GRID_HEIGHT = CANVAS_HEIGHT / TILE_SIZE;

        let snake = [];
        let food = {};
        let dx = TILE_SIZE;
        let dy = 0;         
        let score = 0;
        let currentLevel = 1;
        let isGameOver = true;
        let isPaused = false;
        let directionQueue = []; 
        let focusedButtonIndex = 0;

        const INITIAL_GAME_SPEED = 150;
        const MIN_GAME_SPEED = 50; 
        const LEVEL_THRESHOLD_SCORE = 50;
        const SPEED_DECREMENT_PER_LEVEL = 10;
        
        let gameSpeed = INITIAL_GAME_SPEED; 
        let lastUpdateTime = 0;
        let animationFrameId;

        const PLAY_PAUSE_SPRITE = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
            [0,1,0,0,0,0,0,0,0,0,1,1,0,1,1], 
            [0,1,1,0,0,0,0,0,0,0,1,1,0,1,1], 
            [0,1,1,1,0,0,0,0,0,0,1,1,0,1,1], 
            [0,1,1,1,1,0,0,0,0,0,1,1,0,1,1], 
            [0,1,1,1,1,1,0,0,0,0,1,1,0,1,1], 
            [0,1,1,1,1,1,1,0,0,0,1,1,0,1,1], 
            [0,1,1,1,1,1,1,1,0,0,1,1,0,1,1], 
            [0,1,1,1,1,1,1,0,0,0,1,1,0,1,1], 
            [0,1,1,1,1,1,0,0,0,0,1,1,0,1,1], 
            [0,1,1,1,1,0,0,0,0,0,1,1,0,1,1], 
            [0,1,1,1,0,0,0,0,0,0,1,1,0,1,1], 
            [0,1,1,0,0,0,0,0,0,0,1,1,0,1,1], 
            [0,1,0,0,0,0,0,0,0,0,1,1,0,1,1], 
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];
        const ICON_GRID_SIZE = 15; 
        const ICON_PIXEL_SIZE = ICON_GRID_SIZE * MINI_TILE_SIZE;

        function getRandomPosition() {
            let newPos;
            let occupied;
            do {
                newPos = {
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT) 
                };
                occupied = snake.some(segment => segment.x === newPos.x * TILE_SIZE && segment.y === newPos.y * TILE_SIZE);
            } while (occupied);
            return { x: newPos.x * TILE_SIZE, y: newPos.y * TILE_SIZE };
        }

        function initGame() {
            exitConfirmationModal.classList.add('hidden'); 
            gameOverOverlay.classList.add('hidden');
            canvas.focus(); 
            const startY = Math.floor(GRID_HEIGHT / 2) * TILE_SIZE; 
            snake = [
                { x: 5 * TILE_SIZE, y: startY },
                { x: 4 * TILE_SIZE, y: startY },
                { x: 3 * TILE_SIZE, y: startY }
            ];
            dx = TILE_SIZE; dy = 0; score = 0; currentLevel = 1; isGameOver = false; isPaused = false;
            gameSpeed = INITIAL_GAME_SPEED; lastUpdateTime = 0; directionQueue = [];
            scoreDisplay.textContent = score; levelDisplay.textContent = currentLevel;
            food = getRandomPosition();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop(0);
        }

        function clearCanvas() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        function drawTile(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
        }

        function drawSnake() {
            snake.forEach((segment, index) => {
                const color = index === 0 ? '#10b981' : '#34d399';
                drawTile(segment.x, segment.y, color);
            });
        }

        function drawFood() {
            drawTile(food.x, food.y, '#f59e0b');
        }
        
        function drawBlockyIcon(centerX, centerY, sprite, color) {
            ctx.fillStyle = color;
            const startX = centerX - (ICON_PIXEL_SIZE / 2);
            const startY = centerY - (ICON_PIXEL_SIZE / 2);
            for (let y = 0; y < ICON_GRID_SIZE; y++) {
                for (let x = 0; x < ICON_GRID_SIZE; x++) {
                    if (sprite[y] && sprite[y][x] === 1) { 
                        ctx.fillRect(startX + x * MINI_TILE_SIZE + 1, startY + y * MINI_TILE_SIZE + 1, MINI_TILE_SIZE - 2, MINI_TILE_SIZE - 2); 
                    }
                }
            }
        }

        function drawPauseSymbol() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 
            ctx.font = `2rem 'Press Start 2P', monospace`; 
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fcd34d';
            ctx.fillText("PAUSED", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 120);
            drawBlockyIcon(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30, PLAY_PAUSE_SPRITE, '#fff');
        }

        function draw() {
            clearCanvas();
            drawFood();
            drawSnake();
        }

        function setGameOver(titleText) {
            isGameOver = true;
            isPaused = false;
            exitConfirmationModal.classList.add('hidden');
            gameOverTitle.textContent = titleText;
            gameOverTitle.style.color = (titleText === 'WELCOME' ? '#a7f3d0' : '#ef4444');
            if (titleText === 'WELCOME') {
                finalScoreDisplay.textContent = 'Press START or ENTER to play!';
            } else {
                finalScoreDisplay.textContent = `Final Score: ${score}`;
            }
            gameOverOverlay.classList.remove('hidden');
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            restartButton.focus(); 
        }
        
        function updateModalFocus(index) {
            focusedButtonIndex = index;
            cancelExitButton.classList.remove('focused');
            yesExitButton.classList.remove('focused');
            if (index === 0) {
                cancelExitButton.classList.add('focused');
                cancelExitButton.focus(); 
            } else {
                yesExitButton.classList.add('focused');
                yesExitButton.focus();
            }
        }

        function updateGame() {
            if (isGameOver || isPaused || !exitConfirmationModal.classList.contains('hidden')) return;
            if (directionQueue.length > 0) {
                const nextDirection = directionQueue.shift();
                dx = nextDirection.dx; dy = nextDirection.dy;
            }
            let head = { x: snake[0].x + dx, y: snake[0].y + dy };
            if (head.x < 0) head.x = CANVAS_WIDTH - TILE_SIZE;
            else if (head.x >= CANVAS_WIDTH) head.x = 0;
            if (head.y < 0) head.y = CANVAS_HEIGHT - TILE_SIZE;
            else if (head.y >= CANVAS_HEIGHT) head.y = 0;
            
            if (snake.some((s, i) => i !== 0 && s.x === head.x && s.y === head.y)) {
                setGameOver('GAME OVER');
                return;
            }
            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreDisplay.textContent = score;
                if (score >= currentLevel * LEVEL_THRESHOLD_SCORE) {
                    currentLevel++;
                    levelDisplay.textContent = currentLevel;
                    gameSpeed = Math.max(MIN_GAME_SPEED, INITIAL_GAME_SPEED - (currentLevel - 1) * SPEED_DECREMENT_PER_LEVEL);
                }
                food = getRandomPosition();
            } else {
                snake.pop();
            }
        }

        function gameLoop(currentTime) {
            animationFrameId = requestAnimationFrame(gameLoop);
            if (isPaused) {
                if (exitConfirmationModal.classList.contains('hidden')) drawPauseSymbol();
                return; 
            }
            const deltaTime = currentTime - lastUpdateTime;
            if (deltaTime > gameSpeed) {
                lastUpdateTime = currentTime;
                updateGame();
                draw();
                if (isGameOver) cancelAnimationFrame(animationFrameId);
            }
        }
        
        function handleKeydown(event) {
            const keyPressed = event.key;
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "Enter"].includes(keyPressed)) {
                event.preventDefault();
            }

            if (isGameOver) {
                if (['Enter', 'Escape', ' '].includes(keyPressed)) initGame();
                return;
            }
            
            if (!exitConfirmationModal.classList.contains('hidden')) {
                if (keyPressed === 'Escape') { exitConfirmationModal.classList.add('hidden'); isPaused = false; canvas.focus(); }
                else if (keyPressed === 'ArrowLeft') updateModalFocus(0);
                else if (keyPressed === 'ArrowRight') updateModalFocus(1);
                else if (keyPressed === 'Enter' || keyPressed === ' ') {
                    if (focusedButtonIndex === 0) { exitConfirmationModal.classList.add('hidden'); isPaused = false; }
                    else setGameOver('WELCOME');
                }
                return;
            }

            if (['p', 'P', ' ', 'Enter', 'MediaPlayPause'].includes(keyPressed)) {
                isPaused = !isPaused;
                return;
            }

            if (keyPressed === 'Escape') {
                isPaused = true;
                exitConfirmationModal.classList.remove('hidden');
                updateModalFocus(0);
                return;
            }

            if (isPaused) return;

            const currentDir = directionQueue.length > 0 ? directionQueue[directionQueue.length - 1] : { dx, dy };
            let newDx = 0, newDy = 0;
            if (directionQueue.length >= 2) return;

            switch (keyPressed) {
                case 'ArrowLeft': newDx = -TILE_SIZE; newDy = 0; break;
                case 'ArrowUp': newDx = 0; newDy = -TILE_SIZE; break;
                case 'ArrowRight': newDx = TILE_SIZE; newDy = 0; break;
                case 'ArrowDown': newDx = 0; newDy = TILE_SIZE; break;
                default: return;
            }
            if (!(currentDir.dx === -newDx && currentDir.dy === -newDy)) directionQueue.push({ dx: newDx, dy: newDy });
        }

        document.addEventListener('keydown', handleKeydown);
        restartButton.addEventListener('click', initGame);
        cancelExitButton.addEventListener('click', () => { exitConfirmationModal.classList.add('hidden'); isPaused = false; });
        yesExitButton.addEventListener('click', () => setGameOver('WELCOME')); 

        window.onload = () => {
            canvas.setAttribute('tabindex', '0');
            clearCanvas();
            setGameOver('WELCOME'); 
        };
    </script>
</body>
</html>
