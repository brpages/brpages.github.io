<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#800000">

    <title>Beveled Tetris</title>
    <style>
        :root {
            --bg-color: #001a4b;
            --overlay-color: rgba(0, 10, 40, 0.95);
            --accent-color: #0066FF;
            --meta-theme: #001a4b;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-color: var(--bg-color);
            transition: background-color 0.5s;
        }

        canvas { 
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block; 
            image-rendering: crisp-edges;
        }

        /* Standard Overlay for Menus */
        .overlay-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            background: var(--overlay-color);
            transition: opacity 0.3s;
        }

        #pauseOverlay {
            display: none;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            margin-bottom: 30px;
        }

        .start-btn, .pause-btn {
            padding: 20px 40px;
            font-size: 32px;
            border: 4px solid white;
            color: white;
            cursor: pointer;
            border-radius: 15px;
            font-weight: bold;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            background-color: var(--accent-color);
            transition: transform 0.1s, background-color 0.3s;
            width: 300px;
            text-align: center;
        }

        .start-btn:active, .pause-btn:active {
            transform: scale(0.95);
        }

        #continueBtn { background-color: #28a745; display: none; }
        #resumeBtn { background-color: #0066FF; }
        #restartBtn { background-color: #ffc107; color: black; }
        #quitBtn { background-color: #dc3545; }

        /* Small In-Game Pause Button for Touch/Mouse */
        #gamePauseTrigger {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            z-index: 5;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 15px;
        }

        .theme-buttons { display: flex; gap: 10px; }

        .theme-btn {
            padding: 10px 20px;
            font-size: 18px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            cursor: pointer;
            border-radius: 8px;
        }

        .theme-btn.active { background: white; color: black; }

        @media (min-width: 1000px) {
            .start-btn, .pause-btn {
                padding: 25px 50px;
                font-size: 40px;
                width: 400px;
            }
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <!-- Main Menu -->
        <div id="overlay" class="overlay-layer">
            <h1 style="font-size: 8vw; margin-bottom: 20px; letter-spacing: 5px;">TETRIS</h1>
            <div class="menu-buttons">
                <button class="start-btn" id="continueBtn">CONTINUE</button>
                <button class="start-btn" id="startBtn">NEW GAME</button>
            </div>
            <div class="options-container">
                <p style="margin: 0 0 10px 0; font-size: 1.5vw;">THEME MODE</p>
                <div class="theme-buttons">
                    <button class="theme-btn" id="btn-blue">BLUE</button>
                    <button class="theme-btn" id="btn-red">RED</button>
                    <button class="theme-btn active" id="btn-auto">AUTO</button>
                </div>
                <p id="theme-status" style="margin: 10px 0 0 0; font-size: 1.2vw; opacity: 0.7;">Auto: Night Mode Active</p>
            </div>
        </div>

        <!-- PS4 Style Pause Menu -->
        <div id="pauseOverlay" class="overlay-layer">
            <h2 style="font-size: 5vw; margin-bottom: 40px;">PAUSED</h2>
            <div class="menu-buttons">
                <button class="pause-btn" id="resumeBtn">RESUME</button>
                <button class="pause-btn" id="restartBtn">RESTART</button>
                <button class="pause-btn" id="quitBtn">QUIT TO MENU</button>
            </div>
        </div>

        <div id="gamePauseTrigger">||</div>
        <canvas id="gameCanvas" width="1920" height="1080"></canvas>
    </div>

    <script>
        const TetrisApp = {
            config: {
                COLS: 10,
                ROWS: 20,
                BLOCK_SIZE: 50,
                nextBoxSize: 240,
                SAVE_KEY: 'tetris_save_v1'
            },
            state: {
                arena: [],
                player: { pos: {x: 0, y: 0}, matrix: null, next: null, score: 0 },
                displayScore: 0,
                gameRunning: false,
                isPaused: false,
                lastTime: 0,
                dropCounter: 0,
                dropInterval: 1000,
                themeMode: 'auto',
                spriteLoaded: false
            },

            Storage: {
                save() {
                    const data = {
                        arena: TetrisApp.state.arena,
                        player: TetrisApp.state.player,
                        themeMode: TetrisApp.state.themeMode
                    };
                    localStorage.setItem(TetrisApp.config.SAVE_KEY, JSON.stringify(data));
                },
                load() {
                    const saved = localStorage.getItem(TetrisApp.config.SAVE_KEY);
                    if (!saved) return false;
                    try {
                        const data = JSON.parse(saved);
                        TetrisApp.state.arena = data.arena;
                        TetrisApp.state.player = data.player;
                        TetrisApp.state.displayScore = data.player.score;
                        TetrisApp.state.themeMode = data.themeMode || 'auto';
                        return true;
                    } catch(e) { return false; }
                },
                clear() { localStorage.removeItem(TetrisApp.config.SAVE_KEY); },
                hasSave() { return localStorage.getItem(TetrisApp.config.SAVE_KEY) !== null; }
            },

            Themes: {
                data: {
                    red: { bg: '#4b0000', overlay: 'rgba(40, 0, 0, 0.95)', accent: '#FF0000', meta: '#800000' },
                    blue: { bg: '#001a4b', overlay: 'rgba(0, 10, 40, 0.95)', accent: '#0066FF', meta: '#001a4b' }
                },
                getActive() {
                    if (TetrisApp.state.themeMode === 'red') return this.data.red;
                    if (TetrisApp.state.themeMode === 'blue') return this.data.blue;
                    const hour = new Date().getHours();
                    return (hour >= 18 || hour < 6) ? this.data.red : this.data.blue;
                },
                apply() {
                    const theme = this.getActive();
                    const root = document.documentElement;
                    root.style.setProperty('--bg-color', theme.bg);
                    root.style.setProperty('--overlay-color', theme.overlay);
                    root.style.setProperty('--accent-color', theme.accent);
                    document.querySelector('meta[name="theme-color"]').setAttribute('content', theme.meta);
                    
                    const status = document.getElementById('theme-status');
                    if (TetrisApp.state.themeMode === 'auto') {
                        const isNight = (new Date().getHours() >= 18 || new Date().getHours() < 6);
                        status.innerText = isNight ? "Auto: Night Mode (Red)" : "Auto: Day Mode (Blue)";
                    } else {
                        status.innerText = `Manual: ${TetrisApp.state.themeMode.toUpperCase()}`;
                    }
                    TetrisApp.Renderer.draw();
                }
            },

            Audio: {
                ctx: null,
                init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
                play(type) {
                    if (!this.ctx || TetrisApp.state.isPaused) return;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    const now = this.ctx.currentTime;
                    switch(type) {
                        case 'move':
                            osc.type = 'square'; osc.frequency.setValueAtTime(150, now);
                            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                            gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                            osc.start(); osc.stop(now + 0.1); break;
                        case 'rotate':
                            osc.type = 'square'; osc.frequency.setValueAtTime(400, now);
                            osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                            gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.05);
                            osc.start(); osc.stop(now + 0.05); break;
                        case 'drop':
                            osc.type = 'triangle'; osc.frequency.setValueAtTime(100, now);
                            gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                            osc.start(); osc.stop(now + 0.1); break;
                        case 'clear':
                            [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                                o.type = 'square'; o.frequency.setValueAtTime(freq, now + (i * 0.08));
                                o.connect(g); g.connect(this.ctx.destination);
                                g.gain.setValueAtTime(0.1, now + (i * 0.08));
                                g.gain.exponentialRampToValueAtTime(0.01, now + (i * 0.08) + 0.2);
                                o.start(now + (i * 0.08)); o.stop(now + (i * 0.08) + 0.2);
                            }); break;
                        case 'gameover':
                            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now);
                            osc.frequency.linearRampToValueAtTime(50, now + 1);
                            gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 1);
                            osc.start(); osc.stop(now + 1); break;
                    }
                }
            },

            Assets: {
                blockSprite: new Image(),
                SHAPES: [
                    null,
                    [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
                    [[0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0]],
                    [[0, 3, 3], [3, 3, 0], [0, 0, 0]],
                    [[4, 4, 0], [0, 4, 4], [0, 0, 0]],
                    [[5, 0, 0], [5, 5, 5], [0, 0, 0]],
                    [[6, 6], [6, 6]],
                    [[0, 0, 7], [7, 7, 7], [0, 0, 0]]
                ],
                BOX_ATLAS: {
                    'H': [[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
                    'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
                    'S': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,1],[0,0,0,0,1],[1,1,1,1,1]],
                    'C': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
                    'O': [[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1]],
                    'R': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,1,0],[1,0,0,0,1]],
                    'E': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,1,1,1]],
                    'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1]],
                    'X': [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]],
                    'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
                    'P': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0]],
                    'A': [[0,1,1,1,0],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
                    'U': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1]],
                    '0': [[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1]],
                    '1': [[0,0,1,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
                    '2': [[1,1,1,1,1],[0,0,0,0,1],[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,1]],
                    '3': [[1,1,1,1,1],[0,0,0,0,1],[1,1,1,1,1],[0,0,0,0,1],[1,1,1,1,1]],
                    '4': [[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[0,0,0,0,1],[0,0,0,0,1]],
                    '5': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,1],[0,0,0,0,1],[1,1,1,1,1]],
                    '6': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,1],[1,0,0,0,1],[1,1,1,1,1]],
                    '7': [[1,1,1,1,1],[0,0,0,0,1],[0,0,1,0,0],[0,1,0,0,0],[0,1,0,0,0]],
                    '8': [[1,1,1,1,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,1,1,1,1]],
                    '9': [[1,1,1,1,1],[1,0,0,0,1],[1,1,1,1,1],[0,0,0,0,1],[1,1,1,1,1]],
                    ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
                }
            },

            Physics: {
                createMatrix(w, h) {
                    const matrix = [];
                    while (h--) matrix.push(new Array(w).fill(0));
                    return matrix;
                },
                collide(arena, player) {
                    const [m, o] = [player.matrix, player.pos];
                    if (!m) return false;
                    for (let y = 0; y < m.length; ++y) {
                        for (let x = 0; x < m[y].length; ++x) {
                            if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                        }
                    }
                    return false;
                },
                rotate(matrix, dir) {
                    for (let y = 0; y < matrix.length; ++y) {
                        for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                    }
                    if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
                }
            },

            Renderer: {
                canvas: null, ctx: null,
                offsets: { x: 0, y: 0, uiX: 0, nextY: 0 },
                init() {
                    this.canvas = document.getElementById('gameCanvas');
                    this.ctx = this.canvas.getContext('2d');
                    this.updateOffsets();
                },
                updateOffsets() {
                    const boardW = TetrisApp.config.COLS * TetrisApp.config.BLOCK_SIZE;
                    const boardH = TetrisApp.config.ROWS * TetrisApp.config.BLOCK_SIZE;
                    this.offsets.x = (this.canvas.width - boardW) / 2 - 150;
                    this.offsets.y = (this.canvas.height - boardH) / 2;
                    this.offsets.uiX = this.offsets.x + boardW + 100;
                    this.offsets.nextY = this.offsets.y + 400;
                },
                drawBlock(x, y, colorIndex, size = TetrisApp.config.BLOCK_SIZE, offX, offY, rowOffset = 0) {
                    if (!TetrisApp.state.spriteLoaded) return;
                    offX = offX !== undefined ? offX : this.offsets.x;
                    offY = offY !== undefined ? offY : this.offsets.y;
                    this.ctx.drawImage(TetrisApp.Assets.blockSprite, (colorIndex - 1) * 50, rowOffset, 50, 50, x * size + offX, y * size + offY, size, size);
                },
                drawMatrix(matrix, offset, size = TetrisApp.config.BLOCK_SIZE, offX, offY, rowOffset = 0) {
                    if (!matrix) return;
                    for (let y = 0; y < matrix.length; ++y) {
                        for (let x = 0; x < matrix[y].length; ++x) {
                            if (matrix[y][x] !== 0) this.drawBlock(x + offset.x, y + offset.y, matrix[y][x], size, offX, offY, rowOffset);
                        }
                    }
                },
                drawBoxString(str, x, y, colorIndex, miniBoxSize) {
                    let cursorX = x;
                    str.toUpperCase().split('').forEach(char => {
                        const matrix = TetrisApp.Assets.BOX_ATLAS[char] || TetrisApp.Assets.BOX_ATLAS[' '];
                        matrix.forEach((row, rowIdx) => {
                            row.forEach((cell, colIdx) => {
                                if (cell) this.drawBlock(colIdx, rowIdx, colorIndex, miniBoxSize, cursorX, y);
                            });
                        });
                        cursorX += miniBoxSize * 6;
                    });
                },
                drawGhost() {
                    const p = TetrisApp.state.player;
                    if (!p.matrix) return;
                    const ghostPos = { x: p.pos.x, y: p.pos.y };
                    while (!TetrisApp.Physics.collide(TetrisApp.state.arena, { pos: ghostPos, matrix: p.matrix })) { ghostPos.y++; }
                    ghostPos.y--;
                    this.drawMatrix(p.matrix, ghostPos, TetrisApp.config.BLOCK_SIZE, undefined, undefined, 50);
                },
                draw() {
                    if (!TetrisApp.state.spriteLoaded) return;
                    const theme = TetrisApp.Themes.getActive();
                    const boardW = TetrisApp.config.COLS * TetrisApp.config.BLOCK_SIZE;
                    const boardH = TetrisApp.config.ROWS * TetrisApp.config.BLOCK_SIZE;

                    this.ctx.fillStyle = theme.bg;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = "rgba(0,0,0,0.6)";
                    this.ctx.fillRect(this.offsets.x, this.offsets.y, boardW, boardH);

                    this.ctx.strokeStyle = theme.accent;
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeRect(this.offsets.x, this.offsets.y, boardW, boardH);

                    this.drawMatrix(TetrisApp.state.arena, {x: 0, y: 0});
                    this.drawGhost();
                    this.drawMatrix(TetrisApp.state.player.matrix, TetrisApp.state.player.pos);

                    const mini = 12;
                    this.drawBoxString("HI", this.offsets.uiX, this.offsets.y + 20, 8, mini);
                    this.drawBoxString("SCORE", this.offsets.uiX, this.offsets.y + 110, 2, mini);
                    this.drawBoxString(Math.floor(TetrisApp.state.displayScore).toString(), this.offsets.uiX, this.offsets.y + 200, 6, mini);
                    this.drawBoxString("NEXT", this.offsets.uiX, this.offsets.y + 320, 4, mini);
                    
                    this.ctx.fillStyle = "rgba(0,0,0,0.6)";
                    this.ctx.fillRect(this.offsets.uiX, this.offsets.nextY, TetrisApp.config.nextBoxSize, TetrisApp.config.nextBoxSize);
                    this.ctx.strokeRect(this.offsets.uiX, this.offsets.nextY, TetrisApp.config.nextBoxSize, TetrisApp.config.nextBoxSize);

                    if (TetrisApp.state.player.next) {
                        const s = TetrisApp.config.BLOCK_SIZE * 0.8;
                        const pW = TetrisApp.state.player.next[0].length * s;
                        const pH = TetrisApp.state.player.next.length * s;
                        this.drawMatrix(TetrisApp.state.player.next, {x: 0, y: 0}, s, this.offsets.uiX + (TetrisApp.config.nextBoxSize - pW) / 2, this.offsets.nextY + (TetrisApp.config.nextBoxSize - pH) / 2);
                    }

                    this.ctx.fillStyle = "rgba(255,255,255,0.7)";
                    this.ctx.font = "24px 'Segoe UI'";
                    this.ctx.fillText("CONTROLS:", this.offsets.uiX, this.offsets.y + 750);
                    this.ctx.fillText("D-PAD: MOVE | UP: ROTATE", this.offsets.uiX, this.offsets.y + 790);
                    this.ctx.fillText("ESC/P: PAUSE MENU", this.offsets.uiX, this.offsets.y + 830);

                    this.ctx.lineWidth = 12;
                    this.ctx.strokeRect(6, 6, this.canvas.width - 12, this.canvas.height - 12);
                }
            },

            Actions: {
                togglePause() {
                    if (!TetrisApp.state.gameRunning) return;
                    TetrisApp.state.isPaused = !TetrisApp.state.isPaused;
                    document.getElementById('pauseOverlay').style.display = TetrisApp.state.isPaused ? 'flex' : 'none';
                    if (!TetrisApp.state.isPaused) {
                        TetrisApp.state.lastTime = performance.now();
                        TetrisApp.loop();
                    }
                },
                quitToMenu() {
                    TetrisApp.Storage.save();
                    TetrisApp.state.gameRunning = false;
                    TetrisApp.state.isPaused = false;
                    document.getElementById('pauseOverlay').style.display = 'none';
                    document.getElementById('overlay').style.display = 'flex';
                    document.getElementById('gamePauseTrigger').style.display = 'none';
                    TetrisApp.updateMenuButtons();
                    TetrisApp.Renderer.draw();
                },
                restart() {
                    TetrisApp.state.arena.forEach(row => row.fill(0));
                    TetrisApp.state.player.score = 0;
                    TetrisApp.state.displayScore = 0;
                    this.resetPlayer();
                    TetrisApp.state.isPaused = false;
                    document.getElementById('pauseOverlay').style.display = 'none';
                    TetrisApp.state.lastTime = performance.now();
                    TetrisApp.loop();
                },
                move(dir) {
                    if (TetrisApp.state.isPaused) return;
                    const p = TetrisApp.state.player;
                    p.pos.x += dir;
                    if (TetrisApp.Physics.collide(TetrisApp.state.arena, p)) { p.pos.x -= dir; }
                    else { TetrisApp.Audio.play('move'); }
                },
                drop() {
                    if (TetrisApp.state.isPaused) return;
                    const p = TetrisApp.state.player;
                    p.pos.y++;
                    if (TetrisApp.Physics.collide(TetrisApp.state.arena, p)) {
                        p.pos.y--;
                        this.merge();
                        TetrisApp.Audio.play('drop');
                        this.resetPlayer();
                        this.sweep();
                        TetrisApp.Storage.save();
                    }
                    TetrisApp.state.dropCounter = 0;
                },
                rotate(dir) {
                    if (TetrisApp.state.isPaused) return;
                    const p = TetrisApp.state.player;
                    if (!p.matrix) return;
                    const oldX = p.pos.x;
                    let offset = 1;
                    TetrisApp.Physics.rotate(p.matrix, dir);
                    while (TetrisApp.Physics.collide(TetrisApp.state.arena, p)) {
                        p.pos.x += offset;
                        offset = -(offset + (offset > 0 ? 1 : -1));
                        if (offset > p.matrix[0].length) {
                            TetrisApp.Physics.rotate(p.matrix, -dir);
                            p.pos.x = oldX;
                            return;
                        }
                    }
                    TetrisApp.Audio.play('rotate');
                },
                merge() {
                    const p = TetrisApp.state.player;
                    p.matrix.forEach((row, y) => {
                        row.forEach((val, x) => {
                            if (val !== 0) TetrisApp.state.arena[y + p.pos.y][x + p.pos.x] = val;
                        });
                    });
                },
                sweep() {
                    let rowCount = 1;
                    let cleared = 0;
                    const a = TetrisApp.state.arena;
                    outer: for (let y = a.length - 1; y > 0; --y) {
                        for (let x = 0; x < a[y].length; ++x) { if (a[y][x] === 0) continue outer; }
                        const row = a.splice(y, 1)[0].fill(0);
                        a.unshift(row);
                        ++y;
                        TetrisApp.state.player.score += rowCount * 10;
                        rowCount *= 2;
                        cleared++;
                    }
                    if (cleared > 0) { TetrisApp.Audio.play('clear'); TetrisApp.Storage.save(); }
                },
                resetPlayer() {
                    const p = TetrisApp.state.player;
                    if (!p.next) p.next = this.createPiece();
                    p.matrix = p.next;
                    p.next = this.createPiece();
                    p.pos.y = 0;
                    p.pos.x = (TetrisApp.config.COLS / 2 | 0) - (p.matrix[0].length / 2 | 0);
                    if (TetrisApp.Physics.collide(TetrisApp.state.arena, p)) {
                        TetrisApp.Audio.play('gameover');
                        TetrisApp.state.arena.forEach(row => row.fill(0));
                        p.score = 0; TetrisApp.state.displayScore = 0;
                        TetrisApp.Storage.clear();
                        TetrisApp.state.gameRunning = false;
                        document.getElementById('overlay').style.display = 'flex';
                        document.getElementById('gamePauseTrigger').style.display = 'none';
                        TetrisApp.updateMenuButtons();
                    }
                },
                createPiece() {
                    const pieces = 'ILJOTSZ';
                    const idx = Math.floor(Math.random() * pieces.length);
                    return TetrisApp.Assets.SHAPES[idx + 1].map(row => [...row]);
                }
            },

            loop(time = 0) {
                if (!TetrisApp.state.gameRunning || TetrisApp.state.isPaused) return;
                const dt = time - TetrisApp.state.lastTime;
                TetrisApp.state.lastTime = time;

                if (TetrisApp.state.displayScore < TetrisApp.state.player.score) {
                    TetrisApp.state.displayScore += (TetrisApp.state.player.score - TetrisApp.state.displayScore > 10) ? 2 : 1;
                }

                TetrisApp.state.dropCounter += dt;
                if (TetrisApp.state.dropCounter > TetrisApp.state.dropInterval) TetrisApp.Actions.drop();
                
                TetrisApp.Renderer.draw();
                requestAnimationFrame(t => TetrisApp.loop(t));
            },

            init() {
                TetrisApp.Renderer.init();
                TetrisApp.state.arena = TetrisApp.Physics.createMatrix(TetrisApp.config.COLS, TetrisApp.config.ROWS);
                
                TetrisApp.Assets.blockSprite.src = 'blockSprite.png';
                TetrisApp.Assets.blockSprite.onload = () => {
                    TetrisApp.state.spriteLoaded = true;
                    TetrisApp.Renderer.draw();
                };

                const start = async (isContinue = false) => {
                    if (TetrisApp.state.gameRunning) return;
                    if (isContinue) { TetrisApp.Storage.load(); } 
                    else {
                        TetrisApp.state.arena.forEach(row => row.fill(0));
                        TetrisApp.state.player.score = 0;
                        TetrisApp.state.displayScore = 0;
                        TetrisApp.Actions.resetPlayer();
                    }
                    TetrisApp.Audio.init();
                    document.getElementById('overlay').style.display = 'none';
                    document.getElementById('gamePauseTrigger').style.display = 'flex';
                    TetrisApp.state.gameRunning = true;
                    TetrisApp.state.lastTime = performance.now();
                    TetrisApp.loop();
                };

                // Button Listeners
                document.getElementById('startBtn').onclick = () => start(false);
                document.getElementById('continueBtn').onclick = () => start(true);
                document.getElementById('resumeBtn').onclick = () => TetrisApp.Actions.togglePause();
                document.getElementById('restartBtn').onclick = () => TetrisApp.Actions.restart();
                document.getElementById('quitBtn').onclick = () => TetrisApp.Actions.quitToMenu();
                document.getElementById('gamePauseTrigger').onclick = () => TetrisApp.Actions.togglePause();
                
                document.getElementById('btn-blue').onclick = () => { TetrisApp.state.themeMode = 'blue'; this.updateUI(); };
                document.getElementById('btn-red').onclick = () => { TetrisApp.state.themeMode = 'red'; this.updateUI(); };
                document.getElementById('btn-auto').onclick = () => { TetrisApp.state.themeMode = 'auto'; this.updateUI(); };

                window.addEventListener('keydown', (e) => {
                    if([32, 37, 38, 39, 40, 13, 27, 80].includes(e.keyCode)) e.preventDefault();
                    
                    // Pause Menu Toggles
                    if (e.keyCode === 27 || e.keyCode === 80) { // ESC or P
                        TetrisApp.Actions.togglePause();
                        return;
                    }

                    if (!TetrisApp.state.gameRunning || TetrisApp.state.isPaused) return;
                    if (e.keyCode === 37) TetrisApp.Actions.move(-1);
                    else if (e.keyCode === 39) TetrisApp.Actions.move(1);
                    else if (e.keyCode === 40) TetrisApp.Actions.drop();
                    else if (e.keyCode === 38 || e.keyCode === 13) TetrisApp.Actions.rotate(1);
                });

                this.updateUI();
                this.updateMenuButtons();
                TetrisApp.Renderer.draw();
            },

            updateUI() {
                document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`btn-${TetrisApp.state.themeMode}`).classList.add('active');
                TetrisApp.Themes.apply();
            },

            updateMenuButtons() {
                const continueBtn = document.getElementById('continueBtn');
                continueBtn.style.display = TetrisApp.Storage.hasSave() ? 'block' : 'none';
            }
        };

        window.onload = () => TetrisApp.init();
    </script>
</body>
</html>